Allgemeines
================================================================================
* Das RTOS benötigt exklusiv einen 16-Bit-Timer
	- Andere Module vewenden diesen Timer niemals direkt.
	- Auch ein Compare Channel dieses Timers wird exklusiv benötigt.
	- Ein andere Compare Channel wird exklusiv von 125khz-Leseroutinen
	benutzt.
	- Das RTOS stellt Timerfunktionen zu Verfügung. (Siehe in RTOS_H).
* Interrupts werden niemals für mehr als 4µs gesperrt.
	- Auch Interruptroutinen oder das RTOS tun das nicht!
	- Alle RTOS-Funktion können Interrupts wieder erlauben!
* Interruptroutinen sollen maximal 40µs laufen.
	- Auch dann nicht länger, wenn andere Interrupts erlaubt wurden.
* Jeder Task muss damit rechnen, dass er für bis zu 4ms unterbrochen wird.
* Jedem Task steht minimal ein Fünftel der vom Prozessor bereitgestellten
Rechenzeit zur Verfügung.
* Jeder Task versucht mit so wenig Rechenzeit auszukommen wie möglich.
* fakertos:
	- Jede Funktion muss nach max. 1ms Rechenzeit die Funktion
	task_yield() aufrufen.
	- task_yield() muss nach max. 3ms Rechenzeit zurückkehren!
	- Welche Funktion task_yield() ausführt ist frei definierbar.
		- Z.B. Kommunikation();
* Der Watchdog wird niemals direkt getriggert.
	- Ausnahme für fakertos: In task_yield() ist das erlaubt.
* Portabler, wiederverwendbarer Code!
	- Hardware-abhängige Teile in Treiber oder andere Module auslagern!
	- Keine Copy-Paste-Vererbung!
		- Es sollte keine gleichen Codeteile in unterschiedlichen
		Quelltextdatein geben. Code so schreiben, dass der *selbe* Code
		verwendet wird!
	- Beispiel: Das Mifare-ASIC kann sowohl via SPI als auch über andere
	Schnittstelle angeschlossen sein. Routinen, welche das ASIC benutzen,
	sollten dann so geschrieben sein, dass der *selbe* Code für alle
	möglichen Schnittstellen verwendet werden kann.
	- Beispiel: 13,56MHz-ASICs: Es gibt mehrere ASICs die Mifare lesen
	können. Die Routinen, die das Mifare-Handling implementieren, sollen für
	alle ASICs die *selben* sein.
	- Beispiel: Leser und Programmer: Der Programmer verwendet den *selben*
	Code zum Lesen, wie ein Leser.

================================================================================
* Diverses
Diese Dateien sollte man sich unbedingt mal angucken, da dort evtl. hilfreiche
Dinge vorhanden sind, die man sonst selber machen müsste.

debris/frmwrk/utils/stdmacros.h
debris/frmwrk/utils/misc.h
debris/frmwrk/cpu/avr/common/cpucore.h
debris/frmwrk/cpu/avr/common/bitbuf.h
debris/frmwrk/utils/compiler-gcc.h
debris/frmwrk/cpu/avr/common/ffifo.h (auch für Nutzung innerhalb von Interrupts,
ACHTUNG! Können gloabl Interrupts erlauben!)

================================================================================
* Implementierung:

================================================================================
makefile
--------
in der Nähe von BASE_PATH = ../../../..
--------------------------------------------------------------------------------
RTOS_PATH  = $(SERV_PATH)/125khz/avr
RTOS_PORT_PATH = $(SERV_PATH)/125khz/avr
--------------------------------------------------------------------------------

zu den C-Sourcen hinzufügen:
--------------------------------------------------------------------------------
CSRCS += $(SERV_PATH)/deister/tagtype/tagtype.c
CSRCS += $(SERV_PATH)/deister/tagstruct.c
INC_PATH += $(RTOS_PORT_PATH)
CSRCS += $(RTOS_PORT_PATH)/fakertos.c
--------------------------------------------------------------------------------

an passender Stelle sollte folgendes stehen:
--------------------------------------------------------------------------------
# Device/Platform/Board include path
PLATFORM_INC_PATH += $(CPUS_PATH)/include
PLATFORM_INC_PATH += $(BRDS_PATH)

# Include path
INC_PATH += .
INC_PATH += ../common
--------------------------------------------------------------------------------


================================================================================
config.h:
---------
#define	config_CPU_CLK_HZ	((CPU_XTAL_HZ)/(config_CPU_CLK_PRESCALER))
#define config_CPU_CLK_PRESCALER	(1)
#define config_SYSTEMTIMER_PRESCALER	(8)

#define RTOS_H "fakertos.h"
#define config_FAKERTOS_TASKYIELD_FUNCTION idle_state_function();
#define config_FAKERTOS_TASKYIELD_FCT_PROTO extern void idle_state_function(void);

//Gobal memory for reading routines. The memory space may be used by reading
//routines freely. The application does not use gmem_read while reading
//routines are active. Consider using the OVERLAY-Macro, as there intentionally
//no reference in any header file like this:
//u8 gmem_read[config_SIZEOF_gmem_read];
#define config_SIZEOF_gmem_read		(49)

//Gobal read_tagstruct. Tag reading routines have to return tag data in this
//struct. The memory space of read_tagstruct may be used by reading routines
//freely. The application does not use read_tagstruct while reading routines
//are active. To use: #include "service/deister/tagstruct.h"
//Data is only valid, if a reading routine returned with RFID_READ_SUCCESS.
//Size of the data array in the struct:
#define config_SIZEOF_TAGSTRUCT_DATA		(16)
================================================================================

main.c
------
Beim Startup einmalig (vor der Verwendung der fakertos-Funktionen):
--------------------------------------------------------------------------------
#include "config.h"
#include "utils/stdmacros.h"
#include RTOS_H
	fakertos_timer_init(); //ACHTUNG! Erlaubt global Interrupts!
================================================================================

platinen.hvr (z.b: 217C.hvr)
----------------------------
Dies definiert welcher 16-Bit Timer und welcher Compare Kanal verwendet werden
soll.
--------------------------------------------------------------------------------
#define RTOS_TIMER                      1
#define RTOS_TCOMP                      B

#define MSTICKER_OCTIMER        RTOS_TIMER
#define MSTICKER_OCCHANNEL      RTOS_TCOMP

================================================================================

leseroutine.c
-------------
#include "config.h"

#include "utils/stdmacros.h"
#include "service/deister/tagstruct.h"

#include "leseroutine.h"
#include RTOS_H

typedef struct {
	u8 irgendwas;
	u16 mir_doch_egal;

} gmem_read_leseroutine_type;
OVERLAY(gmem_read, gmem_read_leseroutine_type);

//Benutzung dann überall in diesem Modul mit z.B.:
	gmem_read.irgendwas = 3;
